defineFeatures <- function(){
  
  current = c("Hgb", "Hct", "WBC", "Plt")
  current_prior = c(current, "Hgb_prior", "Hct_prior", "WBC_prior", "Plt_prior")
  current_prior_with_rates = c(current_prior,
                               "Hgb_delta_prop_prior_per_hour", "Hct_delta_prop_prior_per_hour", "WBC_delta_prop_prior_per_hour", "Plt_delta_prop_prior_per_hour")
  current_prior_post = c(current_prior, "Hgb_post", "Hct_post", "WBC_post", "Plt_post")
  current_prior_with_deltas = c(current, 
                                "Hgb_delta_prop_prior", "Hct_delta_prop_prior", "WBC_delta_prop_prior", "Plt_delta_prop_prior")
  current_prior_post_with_rates = c(current_prior_post, 
                                    "Hgb_delta_prop_prior_per_hour", "Hct_delta_prop_prior_per_hour", "WBC_delta_prop_prior_per_hour", "Plt_delta_prop_prior_per_hour",
                                    "Hgb_delta_prop_post_per_hour", "Hct_delta_prop_post_per_hour", "WBC_delta_prop_post_per_hour", "Plt_delta_prop_post_per_hour")
  current_prior_post_with_deltas = c(current, 
                                    "Hgb_delta_prop_prior", "Hct_delta_prop_prior", "WBC_delta_prop_prior", "Plt_delta_prop_prior",
                                    "Hgb_delta_prop_post", "Hct_delta_prop_post", "WBC_delta_prop_post", "Plt_delta_prop_post")
  prior_post_deltas_only = c("Hgb_delta_prop_prior", "Hct_delta_prop_prior", "WBC_delta_prop_prior", "Plt_delta_prop_prior",
                             "Hgb_delta_prop_post", "Hct_delta_prop_post", "WBC_delta_prop_post", "Plt_delta_prop_post")
  current_prior_fold_change = c(current, 
                                "Hgb_fold_change_prior", "Hct_fold_change_prior", "WBC_fold_change_prior", "Plt_fold_change_prior")
  current_prior_post_fold_change = c(current_prior_fold_change, 
                                     "Hgb_fold_change_post", "Hct_fold_change_post", "WBC_fold_change_post", "Plt_fold_change_post")
  current_prior_post_delta_prop = c(current_prior_with_deltas, 
                                    "Hgb_delta_prop_post", "Hct_delta_prop_post", "WBC_delta_prop_post", "Plt_delta_prop_post")
  current_prior_post_with_distance = c(current_prior_post, 
                                       "Hgb_distance", "Hct_distance", "WBC_distance", "Plt_distance",
                                       "Hgb_change", "Hct_change", "WBC_change", "Plt_change")
  
  features <- 
    list(
      current = current,
      current_prior = current_prior,
#      current_prior_with_rates = current_prior_with_rates,
      current_prior_post = current_prior_post,
      prior_post_deltas_only = prior_post_deltas_only,
#      current_prior_post_with_rates = current_prior_post_with_rates, 
#      current_prior_fold_change = current_prior_fold_change,
#      current_prior_post_fold_change = current_prior_post_fold_change,
      current_prior_post_with_deltas = current_prior_post_with_deltas, 
      current_prior_with_deltas = current_prior_with_deltas,
      current_prior_post_with_distance = current_prior_post_with_distance
    )
  
  features
  
}

makeSimulatedTrainingSets <- function(train = tar_read(training_template), feature_set = features[['current']], prevalence = 0.05){
  
  negatives <- 
    train |> 
      filter(!rules_based_contam_flag)
  
  positives_by_rules <- 
    train |> 
      filter(rules_based_contam_flag)
  
  n_positives_to_simulate <- round(nrow(negatives) * prevalence)
  rows_to_simulate <- sample(1:nrow(negatives), n_positives_to_simulate, replace = F)
  
  if(prevalence == 0){ final_negatives = negatives }
  if(prevalence > 0){ final_negatives = negatives[-rows_to_simulate,] }
  
  positives_to_simulate <- negatives[rows_to_simulate,]
  
  mix_ratios <- rbeta(n_positives_to_simulate, 1.5, 7) + 0.10
  mix_ratios[mix_ratios > 0.95] <- 0.95
  
  positives_to_simulate$mix_ratio <- mix_ratios
  
  simulated_positives <- 
    positives_to_simulate |> 
      mutate(
        across(c("Hgb", "Hct", "WBC", "Plt"), ~ round(. * (1 - mix_ratio), 1)),
        Plt = round(Plt),
        across(c("Hgb", "Hct", "WBC", "Plt"), ~ ifelse(. == 0, 0.1, .)),
        across(c("Hgb", "Hct", "WBC", "Plt"), ~ . - get(paste0(cur_column(), "_prior")), .names = "{.col}_delta_prior"),
        across(ends_with("delta_prior"), ~ . / hours_since_prior, .names = "{.col}_per_hour"),
        across(c("Hgb", "Hct", "WBC", "Plt"), ~ get(paste0(cur_column(), "_delta_prior")) / get(paste0(cur_column(), "_prior")) , .names = "{.col}_delta_prop_prior"),
        across(ends_with("delta_prop_prior"), ~ . / hours_since_prior, .names = "{.col}_per_hour"),
        across(c("Hgb", "Hct", "WBC", "Plt"), ~ get(paste0(cur_column(), "_post")) - ., .names = "{.col}_delta_post"),
        across(ends_with("delta_post"), ~ . / hours_to_post, .names = "{.col}_per_hour"),
        across(c("Hgb", "Hct", "WBC", "Plt"), ~ get(paste0(cur_column(), "_delta_post")) / ., .names = "{.col}_delta_prop_post"),
        across(ends_with("delta_prop_post"), ~ . / hours_to_post, .names = "{.col}_per_hour"),
        across(c("Hgb", "Hct", "WBC", "Plt"), ~ abs(get(paste0(cur_column(), "_delta_prior"))) + abs(get(paste0(cur_column(), "_delta_post"))), .names = "{.col}_distance"),
        across(c("Hgb", "Hct", "WBC", "Plt"), ~ abs(get(paste0(cur_column(), "_prior")) - get(paste0(cur_column(), "_post"))), .names = "{.col}_change")
      )
  
  training_set <- 
    bind_rows(
      final_negatives |> mutate(target = 0),
      positives_by_rules |> mutate(target = 1),
      simulated_positives |> mutate(target = 1)
    ) |> 
    mutate(target = as.factor(target)) |> 
    select(all_of(feature_set), target)
  
  training_set

}

defineModels <- function(){
  
  xgboost <- boost_tree(mode = "classification", trees = 1000, tree_depth = 10, min_n = 10) |> set_engine("xgboost", num_threads = 1)
  
  lightgbm <- boost_tree(mode = "classification", trees = tune(), min_n = tune(), learn_rate = 0.5, tree_depth = tune()) |> set_engine("lightgbm", num_threads = 1)
  
  rf <- rand_forest(mode = "classification", trees = 1000) |> set_engine("ranger")
  
  logreg <- logistic_reg(mode = "classification", penalty = 0.5) |> set_engine("glmnet")

  cart <- decision_tree(mode = "classification", tree_depth = 4) |> set_engine("rpart")
  
  list(
    #xgb = xgboost, 
    lgb = lightgbm 
    #rf = rf 
    #logreg = logreg,
    #cart = cart
    )
  
}

tuneWorkflow <- function(wf = tar_read(wf_current_0_xgb)){
  
  library(future)
  plan(multisession, workers = 32)
  
  cv <- vfold_cv(wf |> extract_preprocessor() |> pluck("template"), v = 5)
  
  wf_tuned <- 
    wf |> 
      tune_grid(
        resamples = cv,
        metrics = all_metrics,
        grid = 10, 
        control = control_grid(allow_par = T, parallel_over = "everything", save_pred = T, save_workflow = T, event_level = "second")
      )
  
  plan(sequential)
  
  wf_tuned
  
}

fitWorkflow <- function(wf_tuned = tar_read(wf_tuned_current_prior_0.25_xgb)){
  
  wf <- wf_tuned |> extract_workflow()
  best_param <- wf_tuned |> select_best(metric = "pr_auc")
  train <- wf_tuned |> extract_preprocessor() |> pluck("template")
  
  fit <- fit_best(wf_tuned, verbose = T) |> butcher::butcher(verbose = T)
  
  fit |> bundle::bundle()
  
}

getWorkflowSetRecipes <- function(training_set = tar_read(stack_training_set_WashU_current_prior_post), feature_set = c("current_prior_post")){
  
  library(butcher)
  
  base_rec <- 
    recipe(training_set) |> 
      axe_fitted(verbose = T)
  
  current_prior_post_rec <- 
    base_rec %>% 
      update_role(everything(), new_role = "metadata") %>%
      update_role_requirements("metadata", bake = F) %>%
      update_role(target, new_role = "outcome") %>%
      update_role(c("Hgb", "Plt", "WBC",
                    "Hgb_prior", "Plt_prior", "WBC_prior",
                    "Hgb_post", "Plt_post", "WBC_post"), new_role = "predictor")
  
  deltas_prior_post_rec <- 
    base_rec %>% 
      update_role(everything(), new_role = "metadata") %>%
      update_role_requirements("metadata", bake = F) %>%
      update_role(target, new_role = "outcome") %>%
      update_role(c("Hgb_delta_prior", "Plt_delta_prior", "WBC_delta_prior",
                    "Hgb_delta_post", "Plt_delta_post", "WBC_delta_post"), new_role = "predictor")
  
  current_prior_post_pca_rec <- 
    base_rec %>% 
    update_role(everything(), new_role = "metadata") %>%
    update_role_requirements("metadata", bake = F) %>%
    update_role(target, new_role = "outcome") %>%
    update_role(c("Hgb", "Plt", "WBC",
                  "Hgb_prior", "Plt_prior", "WBC_prior",
                  "Hgb_post", "Plt_post", "WBC_post"), new_role = "predictor") |> 
    step_pca(all_predictors(), threshold = 0.99, keep_original_cols = T, options = list(center = T, scale. = T))
  
  current_deltas_prior_post_pca_rec <- 
    base_rec %>% 
    update_role(everything(), new_role = "metadata") %>%
    update_role_requirements("metadata", bake = F) %>%
    update_role(target, new_role = "outcome") %>%
    update_role(c("Hgb", "Plt", "WBC",
                  "Hgb_delta_prior", "Plt_delta_prior", "WBC_delta_prior",
                  "Hgb_delta_post", "Plt_delta_post", "WBC_delta_post"), new_role = "predictor") |> 
    step_pca(all_predictors(), threshold = 0.99, keep_original_cols = T, options = list(center = T, scale. = T))
  
  current_post_rec <- 
    base_rec %>% 
      update_role(everything(), new_role = "metadata") %>%
      update_role_requirements("metadata", bake = F) %>%
      update_role(target, new_role = "outcome") %>%
      update_role(c("Hgb", "Plt", "WBC",
                    "Hgb_post", "Plt_post", "WBC_post"), new_role = "predictor")
  
  deltas_current_post_rec <- 
    base_rec %>% 
      update_role(everything(), new_role = "metadata") %>%
      update_role_requirements("metadata", bake = F) %>%
      update_role(target, new_role = "outcome") %>%
      update_role(c("Hgb", "Plt", "WBC",
                    "Hgb_delta_post", "Plt_delta_post", "WBC_delta_post",
                    "Hgb_delta_prop_post", "Plt_delta_prop_post", "WBC_delta_prop_post"), new_role = "predictor")

  current_prior_rec <- 
    base_rec %>% 
    update_role(everything(), new_role = "metadata") %>%
    update_role_requirements("metadata", bake = F) %>%
    update_role(target, new_role = "outcome") %>%
    update_role(c("Hgb", "Plt", "WBC",
                  "Hgb_prior", "Plt_prior", "WBC_prior"), new_role = "predictor")
  
  current_deltas_current_prior_rec <- 
    base_rec %>% 
    update_role(everything(), new_role = "metadata") %>%
    update_role_requirements("metadata", bake = F) %>%
    update_role(target, new_role = "outcome") %>%
    update_role(c("Hgb", "Plt", "WBC",
                  "Hgb_delta_prop_prior", "Plt_delta_prop_prior", "WBC_delta_prop_prior"), new_role = "predictor")
  
  current_rec <- 
    base_rec %>% 
      update_role(everything(), new_role = "metadata") %>%
      update_role_requirements("metadata", bake = F) %>%
      update_role(target, new_role = "outcome") %>%
      update_role(c("Hgb", "Plt", "WBC"), new_role = "predictor")
  
  if(feature_set == "current_prior_post"){ 
    output = list(#current_prior_post_rec = current_prior_post_rec, 
                  #deltas_prior_post_rec = deltas_prior_post_rec, 
#                  deltas_prop_with_distances_rec = deltas_prop_with_distances_rec)
#                  current_prior_post_pca_rec = current_prior_post_pca_rec, 
                  current_deltas_prior_post_pca_rec = current_deltas_prior_post_pca_rec) 
#                  current_post_rec = current_post_rec,
#                  deltas_current_post_rec = deltas_current_post_rec,
#                  current_prior_rec = current_prior_rec,
#                  deltas_current_prior_rec = deltas_current_prior_rec,
#                  current_rec = current_rec) 
  }
  
  if(feature_set == "current_prior"){ 
    output = list(current_deltas_current_prior_rec = current_deltas_current_prior_rec) 
  }
  
  if(feature_set == "current"){ 
    output = list(current_rec = current_rec) 
  }

  output
  
}

defineWorkflowSets <- function(train, feature_set = "current_prior_post"){
  
  recipes = getWorkflowSetRecipes(train, feature_set)
  models = defineModels()
  
  wf_set = workflow_set(recipes, models, cross = T)
  
  wf_set
  
}

tuneWorkflowSets <- function(wf_set = tar_read(wf_set_Utah_current_prior_post), train = tar_read(stack_training_set_Utah_current_prior_post)){
  
  library(future)
  plan(multisession, workers = 16)
  
  cv <- vfold_cv(train, v = 5)
  
  wf_set_tuned <- 
    wf_set %>% 
      workflow_map(
        fn = "tune_grid",
        resamples = cv,
        metrics = all_metrics,
        grid = 16, 
        control = control_grid(allow_par = T, parallel_over = "everything", save_pred = T, save_workflow = T, event_level = "second")
      )
  
  plan(sequential)
  
  wf_set_tuned
  
}

fitBestWorkflows <- function(wf_set_tuned = tar_read(wf_set_tuned_Utah_current_prior_post), train = tar_read(stack_training_set_Utah_current_prior_post)){
  
  best_configs <- map(wf_set_tuned$wflow_id, ~extract_workflow_set_result(wf_set_tuned, id = .x) |> select_best(metric = "mn_log_loss"))
  
  wf_set_fit_list <- 
    map2(best_configs, wf_set_tuned$wflow_id, 
         ~extract_workflow(wf_set_tuned, id = .y) |> 
           finalize_workflow(.x) |> 
           fit(train) |> 
           butcher::butcher() |> 
           bundle::bundle()) |>
    setNames(wf_set_tuned$wflow_id) 
  
  wf_set_fit_list
  
}

predictFromWorkflowList <- function(wf_set_fit_list = tar_read(wf_set_fit_Utah_current), test = tar_read(Utah_test_set)){
  
  wf_list <- wf_set_fit_list |> map(bundle::unbundle)
  
  preds <- 
    map(wf_list, ~predict(.x, test, type = "prob") |> select(.pred_1)) |>
    bind_cols() |> 
    setNames(paste0(".pred_1_", names(wf_set_fit_list)))
  
  pred_min <- preds |> apply(1, min)
  pred_max <- preds |> apply(1, max)
  pred_mean <- preds |> apply(1, mean)
  pred_sd <- preds |> apply(1, sd)
  
  summaries <- tibble(pred_min = pred_min, pred_max = pred_max, pred_mean = pred_mean, pred_sd = pred_sd)
  
  out <- bind_cols(test, preds, summaries) |> mutate(pred_class_25 = pred_mean > 0.25, pred_class_50 = pred_mean > 0.5, pred_class_75 = pred_mean > 0.75)
  
  out
  
}

stackWorkflowSet <- function(wf_set_tuned = tar_read(wf_set_tuned_Utah_current_prior_post)){

  library(stacks)
  
  wf_set_fitted <-  
      stacks() %>%
        add_candidates(wf_set_tuned) %>%
        blend_predictions(penalty = 0, mixture = 1, metric = all_metrics, times = 10, control = control_grid(allow_par = T, parallel_over = "everything", save_pred = T, save_workflow = T, event_level = "second")) %>%
        fit_members()
  
  wf_set_fitted
  
}
